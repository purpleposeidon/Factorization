     July 2014            August 2014
Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa
       1  2  3  4  5                  1  2
 6  7  8  9 10 11 12   3  4  5  6  7  8  9
13 14 15 16 17 18 19  10 11 12 13 14 15 16
20 21 22 23 24 25 26  17 18 19 20 21 22 23
27 28 -- 30 31        24 25 26 27 28 29 30
                      31

TODO:
    Git commit. integrate/verify the center-of-rotation offset. Git commit.
    Git commit. DseCollider spawning. Git commit.
    Git commit. Can ray tracing be improved? Git commit.


Time for a task list. Again.

would like:
    proper camera handling, see EntityRenderer.orientCamera; may be able to hack around using FOVUpdateEvent & trickery (well, not super-necessarily that particular event)
    efficient DSE lookup; use a trove int hashmap on System.hashcode(Chunk) to DSE[]

* <-- FZ is here
* Abstract Factory
    Rendering properly
    No collisions
    No rotations
* Chains/Epoxy/Winches
    Collisions
    No rotations (?)
* Rockets
* Commerce
* Orbital Support
* Astrogenisis
* Clamps, Rotors
* Dark iron collosus



✓ Step 1 is "create a dimension"
✓ Step 2 is "give the client an extra world for that dimension"
  Step 3 is "create pseudoplayer, have packets sent to the pseudoplayer be sent to the real players, and render part of the dimension"
✓     -    have packets go to all players near the DSE; single PacketProxyingPlayer per DSE
✓     -    send chunks to players
✓     -    Actually update the terrain when it changes
✓     -    Actually consistently render the terrain when spawned
‽     -    Actually releasing the display list when leaving the dimension
✓ Step 4 is to make the DSE interact with the real world
✓     -    DSE persistence
✓     -    external entity collisions, using custom AABBs
      -    reasonable pushing via translational & rotational motion
  Step 5 is to get player interactions working
      -    placing blocks
      -    activating blocks
      -    GUIs
      -    breaking blocks
              - We'll just do everything ourselves; no trying to go through vanilla code
              - Server-side: Client will send packets similar to Packet14BlockDig; we'll bamboozle ItemInWorldManager (Or replace it with our own, possibly temporarily. This might be better, as it'd be very simple to replace it when we're done.)
              - Client-side: Can we set fields in places to make it do the digging animation? Should be able to do that when rendering DSE. Should work, but if not, use an entity.
              - Do that IWorldAccess partial block breaking rendering on the client; make sure the player packet proxy gets the packets
X Step 6 is to get rotations working (Maybe later)
X     -    Get collisions working when rotated
  Step 7 is rockets & shit.
      -    Refactor DSE & its rendering for Oracles
✓     -    Proper command system
  Step 8 is watch mod interaction burst into flames.
      -    Put in a whitelist for Blocks, Entities, and TileEntities. (Probably a Object.getClass() mapping)
  Step 9 is "drop into incoming; run away giggling."

The hard rendering bit:
  On server:
    the player is made frozen/immortal somehow
    a puppet player is put in hammerspace
    packets go through frozen player normally
    puppet player wraps the packets
  On client:
    we leave our real player behind for the puppet player...
    so we change Minecraft.thePlayer to... the puppet player entity that the server's created

So, rewriting it. When the player gets embedded onto a DSE:
  Create the puppet player, spawn it into hammerspace
  Change the EntityPlayer that the socket is connected to to the puppet.
  Make the real EntityPlayer immortal/ghostly somehow. In particular, skeles need to ignore it. But it still needs to receive all other packets.
  It also needs to stay near the DSE when it moves
  PacketProxyPlayer needs to (or should) stop sending packets to the puppet-mastering player
  puppet player needs to wrap its packets
  Tell the player that they're now controlling the puppet
